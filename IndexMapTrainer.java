import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

public class IndexMapTrainer{
	
	// Simulated annealing parameters from Julian's thesis
	private final double TEMP_INIT = 10;
	private final double TEMP_FINAL = 0.00025;
	private final double COOLING_MULTIPLIER = 0.97;
	private final double MAX_PERTURBATIONS = 200;
	
	public final double[][] CONDITIONAL_PROB; 				// [i][j] : Conditional probability of changing from index i to index j
	
	// Codebook & relevant parameters
	private final List<Double> codebook;
	private final int NUM_BITS; 							// number of bits needed to represent codewords
	private final int SIZE; 								// number of codewords
	Map<Double, Double> codemap;
	Map<Double, Integer> indexCodemap;
	
	
	/**
	 * Constructs an IndexMapTrainer that utilizes the simulated annealing algorithm presented in the thesis.
	 * @param codebook List containing all codewords.
	 * @param trainingChannel Channel used to train data.
	 */
	public IndexMapTrainer (List<Double> codebook, Channel trainingChannel) {
		this.codebook = codebook;
		this.SIZE = codebook.size();
		this.NUM_BITS = (int) (Math.log(codebook.size())/Math.log(2));
		this.CONDITIONAL_PROB = trainingChannel.initializeConditionalProb(SIZE);
	}
	
	/**
	 * Train the index map. Uses the Simulated Annealing (SA) algorithm presented in Julian's thesis.
	 * Note that "state" is the index map in a non-binary form, and the name comes from SA convention.
	 * Additionally, note that the term "energy" is equivalent to expected distortion, but is named as such due to SA convention.
	 * @return Codebook permuted according to the indexMap
	 */
	public List<Double> train(){
		
		// Initialize State
		ArrayList<Integer> state = new ArrayList<Integer>(SIZE);
		ArrayList<Integer> nextState;
		for (int i = 0; i < SIZE; i++)
			state.add(i);
		ArrayList<Integer> bestState = new ArrayList<Integer>(state);
		
		// Initialize System
		double temp = TEMP_INIT;
		int numPertubations = 0;
		// Collections.shuffle(state); // Random initial state
		double energy = expectedDistortion(state);
		double newEnergy;
		double oldEnergy = energy;
		double changeInEnergy; 		// delta in thesis
		
		System.out.println("Simulating annealing for rate " + this.NUM_BITS);
		
		// SA algorithm
		while(temp >= TEMP_FINAL) {
			numPertubations = 0;
			while(numPertubations++ < MAX_PERTURBATIONS) {
				// Randomly select new state
				nextState = new ArrayList<Integer>(state);
				Collections.shuffle(nextState);
				newEnergy = expectedDistortion(nextState);
				changeInEnergy = newEnergy - energy;
				
				// Decide whether to accept new state
				if (changeInEnergy < 0) {
					state = new ArrayList<Integer>(nextState);
					energy = newEnergy;
				}
				else if (acceptNewState(changeInEnergy, temp)) {
					state = new ArrayList<Integer>(nextState);
					energy = newEnergy;
				}
				
				// Check to see if energy has dropped
				if (energy < oldEnergy) {
					numPertubations = 0;
					oldEnergy = energy;
					bestState = state;
				}
			}
			
			temp *= COOLING_MULTIPLIER; // cool system
		}

		// create new codebook
		List<Double> permutedCodebook = new ArrayList<Double>(SIZE);
		for (int i = 0; i < SIZE; i++)
			permutedCodebook.add((double) 0);
		for (int i = 0; i < SIZE; i++)
			permutedCodebook.set(bestState.get(i), codebook.get(i));
		if (SIZE == 4)
			System.out.println(permutedCodebook);
		return permutedCodebook;
	}
	
	/**
	 * Computes whether the next state will be accepted or not.
	 * @param changeInEnergy Change in energy between new state and old state.
	 * @param temp Temperature of the system.
	 * @return	Boolean informing the algorithm whether or not to accept the new state.
	 */
	private boolean acceptNewState(double changeInEnergy, double temp) {
		double random = Math.random();
		return (random > Math.exp(-changeInEnergy / temp));
	}

	/**
	 * Computes the expected distortion (energy) using the user-provided set of training data.
	 * @param trainingData	List of source words generated by some distribution.
	 * @param state	Current state of the system.
	 * @return Expected distortion (energy).
	 */
	private double expectedDistortion(ArrayList<Integer> state) {
		double expectedDistortion = 0;
		for (int i = 0; i < SIZE; i++) {
			for (int j = 0; j < SIZE; j ++)
				expectedDistortion += CONDITIONAL_PROB[state.get(i)][state.get(j)] * Math.pow(codebook.get(i) - codebook.get(j), 2);
		}
		return expectedDistortion;
	}
}

